# ワークフローの名前
name: .NET WPF Release

# ワークフローが実行されるタイミングを定義
on:
  push:
    tags:
      - "v*.*.*" # vで始まり、.が2つ含まれるタグ（例: v0.1.2, v0.1.2-beta）で実行

  workflow_dispatch:

# 実行される一連のタスク（ジョブ）を定義
jobs:
  build-and-release:
    # ジョブの名前
    name: Build and Release
    # 実行環境を指定。WPFはWindowsが必須
    runs-on: windows-latest

    # GitHubリリースを作成・編集するために、リポジトリのコンテンツへの書き込み権限を付与します。
    permissions:
      contents: write

    steps:
      # 1. リポジトリのソースコードをチェックアウトする
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. .NET SDKをセットアップする
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          # プロジェクトで使用している.NETのバージョンを指定
          dotnet-version: "8.0.x"

      # 3. MSBuildをセットアップする (インストーラーのビルドに必要)
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      # 4. ソリューション全体のNuGetパッケージを復元する
      - name: Restore NuGet packages
        # ソリューションファイル名を指定してください
        run: dotnet restore ClipboardUtility.sln

      # 4a. タグ名からバージョン番号を抽出
      - name: Extract version number from tag
        id: extract_version
        run: |
          # タグ名 (v1.2.3 や v1.2.3-beta) から 'v' と '-beta' などのプレリリース部分を除去
          $VERSION_NUMBER = "${{ github.ref_name }}" -replace '^v', '' -replace '-.*', ''
          Write-Host "Extracted version: $VERSION_NUMBER"
          # 抽出したバージョン番号を、後のステップで使えるように 'outputs' にセット
          echo "VERSION_NUMBER=$VERSION_NUMBER" >> $env:GITHUB_OUTPUT
      # 4b. .resx ファイル内のバージョンを置換
      - name: Update version in .resx file
        run: |
          $VERSION_NUMBER = "${{ steps.extract_version.outputs.VERSION_NUMBER }}"
          $RESX_PATH = "ClipboardUtility/src/Properties/Resources.resx"
          $RESOURCE_KEY = "AppVersion"

          Write-Host "Debug: Attempting to update .resx file..."
          Write-Host "Debug:   VERSION_NUMBER: '$VERSION_NUMBER'"
          Write-Host "Debug:   RESX_PATH: '$RESX_PATH'"
          Write-Host "Debug:   RESOURCE_KEY: '$RESOURCE_KEY'"

          if (-not (Test-Path $RESX_PATH)) {
            Write-Error "Debug: File not found at $RESX_PATH"
            # 実行中のディレクトリ構造を表示して、パスが正しいか確認する
            Get-ChildItem -Recurse | Select-Object FullName -First 20
            exit 1
          }
          Write-Host "Debug: File found at $RESX_PATH."

          Write-Host "Updating $RESX_PATH ($RESOURCE_KEY) with version: $VERSION_NUMBER"

          # Get-Content に -Raw を追加すると、1つの文字列として読み込めて確実な場合があります
          $xml = [xml](Get-Content $RESX_PATH -Raw -Encoding UTF8) 
          $node = $xml.SelectSingleNode("//data[@name='$RESOURCE_KEY']/value")

          if ($node) {
            Write-Host "Debug: Node found. Current value: '$($node.'#text')'"

            $node.'#text' = $VERSION_NUMBER
            
            Write-Host "Debug: Node updated. New value set to: '$($node.'#text')'"

            $xml.Save($RESX_PATH)
            Write-Host "Successfully updated $RESX_PATH"

            Write-Host "Debug: Verifying content after save..."
            $verifyXml = [xml](Get-Content $RESX_PATH -Raw -Encoding UTF8)
            $verifyNode = $verifyXml.SelectSingleNode("//data[@name='$RESOURCE_KEY']/value")
            Write-Host "Debug: Value in file after save: '$($verifyNode.'#text')'"
            if ($verifyNode.'#text' -eq $VERSION_NUMBER) {
              Write-Host "Debug: Verification successful."
            } else {
              Write-Warning "Debug: Verification FAILED. Value mismatch after save."
            }

          } else {
            Write-Error "Resource key '$RESOURCE_KEY' not found in $RESX_PATH"
            
            Write-Host "Debug: Node NOT found. Dumping available data nodes (name attributes) to check spelling:"
            $allDataNodes = $xml.SelectNodes("//data")
            foreach ($dataNode in $allDataNodes) {
              Write-Host "Debug:   Found data node with name: '$($dataNode.name)'"
            }

            exit 1
          }

      # 4a. タグとインストーラーのバージョンを比較
      - name: Compare Tag Version with Installer Version
        run: |
          # タグ名 (v1.0.1 や v1.0.1-beta) から 'v' と '-beta' などを除去
          $TAG_VERSION = "${{ github.ref_name }}" -replace '^v', '' -replace '-.*', ''
          Write-Host "Checking Tag Version: $TAG_VERSION"

          $VDPROJ_PATH = "ClipboardUtilityInstaller/ClipboardUtilityInstaller.vdproj"

          # .vdproj ファイルから "ProductVersion" = "8:1.0.0" の行を探す
          $FILE_CONTENT = Get-Content $VDPROJ_PATH
          $FILE_VERSION_LINE = $FILE_CONTENT | Select-String -Pattern '("ProductVersion" = "8:)([\d\.]+)"'

          if (-not $FILE_VERSION_LINE) {
            Write-Error "Could not find 'ProductVersion' in $VDPROJ_PATH"
            exit 1
          }

          # マッチした部分からバージョン番号(例: 1.0.0)のみを抽出
          $FILE_VERSION = $FILE_VERSION_LINE.Matches.Groups[2].Value
          Write-Host "Found Installer Version: $FILE_VERSION"

          # バージョンを比較
          if ($TAG_VERSION -ne $FILE_VERSION) {
            Write-Error "Tag version ($TAG_VERSION) does not match installer version ($FILE_VERSION). Please update $VDPROJ_PATH and re-tag."
            exit 1
          }

          Write-Host "Versions match. Proceeding with build."
      # 5. WPFアプリケーションを発行する (単一exeファイル用)
      - name: Publish WPF Application
        run: dotnet publish --configuration Release --runtime win-x64 --self-contained true -p:PublishSingleFile=true -o ./publish ClipboardUtility/ClipboardUtility.csproj
        # --configuration Release: リリースモードでビルド
        # --runtime win-x64: 64bitのWindows向けにビルド
        # --self-contained true: .NETがインストールされていなくても動くように自己完結型でビルド
        # -p:PublishSingleFile=true: 関連ファイルを含んだ単一の.exeファイルとして出力
        # -o ./publish: 'publish'という名前のフォルダに出力

      # 6. MSIインストーラーをビルドする
      - name: Build MSI Installer
        run: |
          & "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\devenv.com" "ClipboardUtility.sln" /Build "Release|Any CPU" /Project "ClipboardUtilityInstaller"

          Write-Host "--- Displaying IDE Activity Log (ide_activity.log) ---"
          if (Test-Path "ide_activity.log") {
            # XML形式のログなので、中身をそのままテキストとして表示
            Get-Content "ide_activity.log" -Encoding UTF8 -ErrorAction SilentlyContinue
          } else {
            Write-Warning "ide_activity.log not found."
          }
      # 7. noadmin版インストーラー用のファイルを作成し、UAC要求を削除する
      - name: Create and Modify NoAdmin Installer Version
        run: |
          # noadmin版を格納する新しいディレクトリを作成
          New-Item -ItemType Directory -Force -Path "./ClipboardUtilityInstaller/Release-NoAdmin"

          # ビルドされた通常版のファイルをnoadmin用のディレクトリにコピー
          Copy-Item -Path ./ClipboardUtilityInstaller/Release/* -Destination ./ClipboardUtilityInstaller/Release-NoAdmin/ -Recurse

          # Windows SDKの中から最新のmsiinfo.exeを探す
          $sdkPath = (Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "msiinfo.exe" -Recurse | Sort-Object FullName -Descending | Select-Object -First 1).FullName
          if (-not $sdkPath) {
            Write-Error "msiinfo.exe not found in Windows SDK."
            exit 1
          }
          Write-Host "Found msiinfo.exe at $sdkPath"

          # コピーされたMSIファイルのパスを指定
          $msiPath = "./ClipboardUtilityInstaller/Release-NoAdmin/ClipboardUtilityInstaller.msi"

          # コピーされたMSIファイルからUAC昇格要求を削除
          Write-Host "Modifying $msiPath to remove UAC requirement..."
          & $sdkPath $msiPath /W 10

      # 8. README.mdをpublishディレクトリにコピーする
      - name: Copy README to publish folder
        run: Copy-Item -Path ./README* -Destination ./publish/

      # 9. 単一exeファイルの成果物をZIPに圧縮する
      - name: Zip the standalone artifact
        run: Compress-Archive -Path ./publish/* -DestinationPath ClipboardUtility-Standalone-${{ github.ref_name }}.zip

      # 10. 通常版インストーラーの成果物をZIPに圧縮する
      - name: Zip the normal installer artifact
        run: Compress-Archive -Path ./ClipboardUtilityInstaller/Release/* -DestinationPath ClipboardUtility-Installer-${{ github.ref_name }}.zip

      # 11. noadmin版インストーラーの成果物をZIPに圧縮する
      - name: Zip the no-admin installer artifact
        run: Compress-Archive -Path ./ClipboardUtilityInstaller/Release-NoAdmin/* -DestinationPath ClipboardUtility-Installer-NoAdmin-${{ github.ref_name }}.zip

      # 12. GitHubリリースを作成する
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          # タグ名にハイフンが含まれていれば true (プレリリース) に、そうでなければ false (通常リリース) になります
          prerelease: ${{ contains(github.ref_name, '-') }}

      # 13. 単一exe版(ZIP)をリリースにアップロードする
      - name: Upload Standalone Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./ClipboardUtility-Standalone-${{ github.ref_name }}.zip
          asset_name: ClipboardUtility-Standalone-${{ github.ref_name }}.zip
          asset_content_type: application/zip

      # 14. 通常版インストーラー(ZIP)をリリースにアップロードする
      - name: Upload Normal Installer Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./ClipboardUtility-Installer-${{ github.ref_name }}.zip
          asset_name: ClipboardUtility-Installer-${{ github.ref_name }}.zip
          asset_content_type: application/zip

      # 15. noadmin版インストーラー(ZIP)をリリースにアップロードする
      - name: Upload NoAdmin Installer Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./ClipboardUtility-Installer-NoAdmin-${{ github.ref_name }}.zip
          asset_name: ClipboardUtility-Installer-NoAdmin-${{ github.ref_name }}.zip
          asset_content_type: application/zip
