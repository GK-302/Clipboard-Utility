name: Release App & Deploy Site

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:

# 権限設定: ReleasesへのアップロードとPagesへのデプロイに必要
permissions:
  contents: write
  pages: write
  id-token: write

# 同時実行の制御 (Pagesデプロイ用)
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # ==============================================================================
  # JOB 1: アプリのビルド、署名、リリース作成 (Windows環境)
  # ==============================================================================
  build-windows-assets:
    runs-on: windows-latest
    # 【追加】次のジョブに変数を渡す設定
    outputs:
      msix_folder: ${{ steps.msix_path_resolver.outputs.FOLDER_NAME }}

    env:
      # MSIX関連の設定
      PACKAGE_PROJECT: "ClipboardUtilityMSIXInstaller/ClipboardUtilityMSIXInstaller.wapproj"
      APPINSTALLER_FILENAME: "ClipboardUtilityMSIXInstaller.appinstaller"
      # Pagesの公開URL (Jekyllの構成に合わせて設定)
      APPINSTALLER_URL: "https://gk-302.github.io/Clipboard-Utility/download"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --- セットアップ関連 ---
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            8.0.x
            7.0.x
          workloads: microsoft-net-sdk-windowsdesktop

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Install License Tool
        run: dotnet tool install --global dotnet-project-licenses

      # --- 証明書の準備 ---
      - name: Decode PFX Certificate
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "signing_cert.pfx"
          [System.IO.File]::WriteAllBytes($pfxPath, [System.Convert]::FromBase64String("${{ secrets.PFX_BASE64 }}"))
          echo "PFX_PATH=$pfxPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        shell: pwsh

      # --- バージョン情報の抽出と設定 ---
      - name: Extract Version
        id: extract_version
        run: |
          $rawTag = "${{ github.ref_name }}"
          $version = $rawTag -replace '^v', '' -replace '-.*', ''
          $version4digit = "$version.0"

          echo "VERSION_NUMBER=$version" >> $env:GITHUB_OUTPUT
          echo "VERSION_4_DIGITS=$version4digit" >> $env:GITHUB_OUTPUT
          echo "RELEASE_TAG=$rawTag" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        shell: pwsh

      - name: Update Projects Version
        run: |
          $version = "${{ steps.extract_version.outputs.VERSION_4_DIGITS }}"

          # 1. Update csproj
          $csproj = "ClipboardUtility/ClipboardUtility.csproj"
          [xml]$xmlCs = Get-Content $csproj
          $node = $xmlCs.SelectSingleNode("//PropertyGroup/Version")
          if ($node) { $node.InnerText = $version; $xmlCs.Save($csproj) }

          # 2. Update appxmanifest (MSIX)
          $manifest = "ClipboardUtilityMSIXInstaller/Package.appxmanifest"
          [xml]$xmlMx = Get-Content $manifest
          $xmlMx.Package.Identity.Version = $version
          $xmlMx.Save($manifest)
        shell: pwsh

      # --- ビルド & ライセンス生成 ---
      - name: Restore & Generate License
        run: |
          # 【修正】コマンドライン引数ではなく、csprojを直接書き換えてRIDsを追加します
          # これにより "project.assets.json doesn't have a target..." エラーを確実に防ぎます
          $csprojPath = "ClipboardUtility/ClipboardUtility.csproj"
          [xml]$xml = Get-Content $csprojPath

          # PropertyGroupを取得 (通常は最初のPropertyGroup)
          $propGroup = $xml.Project.PropertyGroup | Select-Object -First 1

          # RuntimeIdentifiersノードがない場合のみ追加
          if (-not $propGroup.SelectSingleNode("*[local-name()='RuntimeIdentifiers']")) {
              $node = $xml.CreateElement("RuntimeIdentifiers", $xml.Project.NamespaceURI)
              $node.InnerText = "win-x86;win-x64"
              $propGroup.AppendChild($node)
              $xml.Save($csprojPath)
              Write-Host "Successfully added RuntimeIdentifiers to csproj."
          } else {
              Write-Host "RuntimeIdentifiers already exists."
          }

          # 変更後のファイルで復元を実行 (引数は不要になります)
          dotnet restore ClipboardUtility.sln

          # ライセンス生成
          New-Item -ItemType Directory -Force -Path "./ClipboardUtility/src/Assets"
          dotnet-project-licenses -i ./ClipboardUtility/ClipboardUtility.csproj --outfile ./ClipboardUtility/src/Assets/licenses.json -j
        shell:
          pwsh

          # --- 1. Standalone EXE ビルド ---
      - name: Publish WPF App (Standalone)
        run: |
          dotnet publish --configuration Release --runtime win-x64 --self-contained true -p:PublishSingleFile=true -o ./publish ClipboardUtility/ClipboardUtility.csproj
          Copy-Item -Path ./ClipboardUtility/src/Assets/licenses.json -Destination ./publish/
          Copy-Item -Path ./README* -Destination ./publish/

      # --- 2. MSI インストーラービルド ---
      - name: Build MSI Installer
        run: |
          & "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\devenv.com" "ClipboardUtility.sln" /Build "Release|Any CPU" /Project "ClipboardUtilityInstaller"

      - name: Create NoAdmin MSI
        run: |
          New-Item -ItemType Directory -Force -Path "./ClipboardUtilityInstaller/Release-NoAdmin"
          Copy-Item -Path ./ClipboardUtilityInstaller/Release/* -Destination ./ClipboardUtilityInstaller/Release-NoAdmin/ -Recurse
          $sdkPath = (Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "msiinfo.exe" -Recurse | Select-Object -First 1).FullName
          & $sdkPath "./ClipboardUtilityInstaller/Release-NoAdmin/ClipboardUtilityInstaller.msi" /W 10

      # --- 3. MSIX インストーラービルド ---
      - name: Build MSIX Installer (wapproj)
        run: |
          $msixOut = Join-Path $env:GITHUB_WORKSPACE 'msix_output'

          msbuild "${{ env.PACKAGE_PROJECT }}" `
            /p:Configuration=Release `
            /p:Platform=x64 `
            /p:AppxPackageDir="$msixOut" `
            /p:AppxPackageSigningEnabled=true `
            /p:PackageCertificateKeyFile="${{ env.PFX_PATH }}" `
            /p:PackageCertificatePassword="${{ secrets.PFX_PASSWORD }}" `
            /p:UapAppxPackageBuildMode=SideloadOnly `
            /p:GenerateAppInstallerFile=true `
            /p:AppInstallerUri="${{ env.APPINSTALLER_URL }}" `
            /p:AppInstallerUpdateFrequency=OnApplicationRun `
            /p:AppInstallerCheckForUpdateFrequency=OnApplicationRun
        shell: pwsh

      # --- アーティファクトの保存 (Job間の受け渡し用) ---
      # これが「Jekyllビルド」JobへMSIXフォルダを渡すための鍵です
      - name: Determine MSIX upload path
        id: msix_path_resolver
        run: |
          $search = Join-Path $env:GITHUB_WORKSPACE 'msix_output'
          Write-Host "Searching for .msixbundle or .msix under $search"
          $packageFile = Get-ChildItem -Path $search -Include '*.msixbundle', '*.msix' -Recurse -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -eq $packageFile) {
            Write-Host "No .msixbundle or .msix found under $search. Listing directory for debugging:"
            Get-ChildItem -Path $search -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
            Write-Error "MSIX package not found. Aborting upload to avoid creating empty artifact."
            exit 1
          }
          $folder = $packageFile.DirectoryName
          Write-Host "Found MSIX folder: $folder"
          echo "UPLOAD_PATH=$folder" >> $env:GITHUB_ENV
          echo "FOLDER_NAME=$($packageFile.Directory.Name)" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Upload MSIX Artifact for Site Build
        uses: actions/upload-artifact@v4
        with:
          name: msix-package
          path: ${{ env.UPLOAD_PATH }}
          retention-days: 1

      # --- リリースへのアップロード (zip圧縮含む) ---
      - name: Zip Artifacts
        run: |
          Compress-Archive -Path ./publish/* -DestinationPath ClipboardUtility-Standalone-${{ env.RELEASE_TAG }}.zip
          Compress-Archive -Path ./ClipboardUtilityInstaller/Release/* -DestinationPath ClipboardUtility-Installer-${{ env.RELEASE_TAG }}.zip
          Compress-Archive -Path ./ClipboardUtilityInstaller/Release-NoAdmin/* -DestinationPath ClipboardUtility-Installer-NoAdmin-${{ env.RELEASE_TAG }}.zip

      - name: Release to GitHub
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: Release ${{ env.RELEASE_TAG }}
          prerelease: ${{ contains(env.RELEASE_TAG, '-') }}
          files: |
            *.zip
            ${{ env.UPLOAD_PATH }}/*.msix*
            ${{ env.UPLOAD_PATH }}/*.appinstaller

      - name: Cleanup Certificate
        if: always()
        run: Remove-Item -Path "${{ env.PFX_PATH }}" -Force
        shell: pwsh

  # ==============================================================================
  # JOB 2: Jekyllサイトのビルド (Ubuntu環境)
  # ==============================================================================
  build-site:
    needs: build-windows-assets # Windowsでのビルドが終わってから実行
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      # Windows Jobで作ったMSIXフォルダをダウンロード
      - name: Download MSIX Artifact
        uses: actions/download-artifact@v4
        with:
          name: msix-package
          # 一時フォルダに保存
          path: ./temp_msix_assets

      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5


      - name: Build with Jekyll
        uses: actions/jekyll-build-pages@v1
        with:
          source: ./
          destination: ./_site

      # --- デバッグと配置の修正 ---
      - name: Inject MSIX into Site
        run: |
          echo "=== [Debug] Content of temp_msix_assets ==="
          ls -R ./temp_msix_assets
          
          FIXED_FOLDER_NAME="download"
          DEST_DIR="./_site/$FIXED_FOLDER_NAME"
          
          echo "Creating directory: $DEST_DIR"
          mkdir -p "$DEST_DIR"
          
          # 中身を移動 (sudoは使わない！)
          # フォルダ階層のズレを吸収するため、再帰的に index.html を探して配置する方法も検討できますが
          # まずは単純な移動で、ログを見て判断します。
          cp -r ./temp_msix_assets/* "$DEST_DIR/"
          
          echo "=== [Debug] Content of _site directory ==="
          ls -R ./_site
        
      - name: Upload artifact for Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./_site

  # ==============================================================================
  # JOB 3: デプロイ (GitHub Pages)
  # ==============================================================================
  deploy-pages:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build-site
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
